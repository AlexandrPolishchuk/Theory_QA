•	Что подразумевается под тестовой средой?

Тестовая среда -это отдельное окружение, где можно спокойно проверять доработанный или вновь созданный функционал, и не боятся что ошибки попадут к конечному пользователю. Тестовая среда зачастую считается банальной копией рабочего окружения, которая не видна конечному пользователю, но максимально похожа на конечную версию продукта. 

•	В чем отличие build от release?

Билд — это в буквальном переводе — "сборка". Т.е. мы берём срез исходников, создаём исполняемые файлы, конфиги, скрипты SQL и т.п. Т.е. билд — полученные из исходников рабочие продукты. Создаётся как вручную по требованию, так и автоматическими системами сборок по расписанию. Как угодно, в общем — было бы что собирать.
Релиз — это билд, который команда разработчиков предоставляет во внешнюю среду. В качестве потребителя релиза может быть, как команда тестеров, так и пользователи. Соответственно, внутренний релиз — это тестовый релиз, который должна тестировать группа тестирования, внешний релиз — это релиз, который поставляются заказчику.

•	Основные фазы тестирования?

Необходимость проведения тестирования в несколько этапов определяется тем, что разные типы ошибок проще всего обнаруживаются на разных этапах. Основными фазами тестирования являются:


– модульное тестирование;
– интеграционное тестирование;
– системное тестирование (в том числе адаптационное, функциональное и нагрузочное);
– регрессионное тестирование;
– приемочное тестирование.
На стадии модульного тестирования достаточно просто выявляются просчеты в логике построения модуля и/или реализации алгоритмов, ошибки, связанные с неправильным использованием локальных ресурсов, а также ошибки в локальных переменных.


Следующим этапом является интеграционное тестирование. Оно проходит в несколько стадий и заключается в тестировании частей системы, состоящих из двух и большего количества модулей. На стадии интеграционного тестирования ошибки управления потоком, ошибки в передаче и/или интерпретации данных, использовании ресурсов, средств коммуникации.


Третьим этапом является системное тестирование, которое существенным образом отличается от модульного и интеграционного. Оно рассматривает систему как черный ящик и работает исключительно с пользовательскими интерфейсами. Основной целью системного тестирования является проверка стабильности и корректности работы системы, а также соответствия функциональности системы спецификациям, указанным в сопроводительных документах, проверяется работы системы на базе различных операционных систем и аппаратного обеспечения. Исследуется производительность тестируемого программного обеспечения.


Основной целью регрессионного тестирования является проверка того, что в результате внесения изменений в программный код зафиксированные ранее ошибки исправлены, а новые не появляются. Для регрессионного тестирования используется специально разработанный набор тестов, из которого каждый раз выбираются те тесты, которые позволяют обнаружить появление новых ошибок с наибольшей вероятностью.


Приемочное тестирование — тестирование интегральной функциональности системы на соответствие требованиям заказчика. Планируется с участием представителей заказчика. Проводится на заключительном этапе с целью удостовериться в том, что система работает так, как и ожидалось, все необходимые формы, процедуры присутствуют и функционируют нормально. Данное тестирование является высокоуровневой проверкой отсутствия пробелов в функциональности системы.


Положительные результаты бизнес-тестирования означают, что все компоненты системы работоспособны и включены в данную версию продукта.

•	Что такое импакт анализ?

Impact Analysis (импакт анализ) - это исследование, которое позволяет указать затронутые места (affected areas) в проекте при разработке новой или изменении старой функциональности, а также определить, насколько значительно они были затронуты. Затронутые области требуют большего внимания во время проведения регрессионного тестирования. Импакт анализ может быть полезным в следующих случаях:
 -есть изменения в требованиях;
 -получен запрос на внесение изменений в продукт;
 -ожидается внедрение нового модуля или функциональности в существующий продукт;
 -каждый раз, когда есть изменения в существующих модулях или функциональностях продукта.

•	Критерии выбора тестов?

Требования к идеальному критерию тестирования:

  1)Критерий должен быть достаточным, т.е. показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы.
  2)Критерий должен быть полным, т.е. в случае ошибки должен существовать тест из множества тестов, удовлетворяющих критерию, который раскрывает ошибку.
  3)Критерий должен быть надежным, т.е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы.
  4)Критерий должен быть легко проверяемым, например вычисляемым на тестах.
Для нетривиальных классов программ в общем случае не существует полного и надежного критерия, зависящего от программ или спецификаций. Поэтому мы стремимся к идеальному общему критерию через реальные частные. 
     Классы критериев:
 -Структурные критерии используют информацию о структуре программы (критерии так называемого "белого ящика").
 -Функциональные критерии формулируются в описании требований к программному изделию ( критерии так называемого "черного ящика" ).
 -Критерии стохастического тестирования формулируются в терминах проверки наличия заданных свойств у тестируемого приложения, средствами проверки некоторой статистической гипотезы.
 -Мутационные критерии ориентированы на проверку свойств программного изделия на основе подхода Монте-Карло.
     Структурные критерии используют модель программы в виде "белого ящика", что предполагает знание исходного текста программы или спецификации программы в виде потокового графа управления. Структурная информация понятна и доступна разработчикам подсистем и модулей приложения, поэтому данный класс критериев часто используется на этапах модульного и интеграционного тестирования (Unit testing, Integration testing). Структурные критерии базируются на основных элементах УГП (Управляющий граф программы), операторах, ветвях и путях.
   Условие критерия тестирования команд (критерий С0) - набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. Это слабый критерий, он, как правило, используется в больших программных системах, где другие критерии применить невозможно.
   Условие критерия тестирования ветвей (критерий С1) - набор тестов в совокупности должен обеспечить прохождение каждой ветви не менее одного раза. Это достаточно сильный и при этом экономичный критерий, поскольку множество ветвей в тестируемом приложении конечно и не так уж велико. Данный критерий часто используется в системах автоматизации тестирования.
   Условие критерия тестирования путей (критерий С2) - набор тестов в совокупности должен обеспечить прохождение каждого пути не менее 1 раза. Если программа содержит цикл (в особенности с неявно заданным числом итераций), то число итераций ограничивается константой (часто - 2, или числом классов выходных путей).
Структурные критерии не проверяют соответствие спецификации, если оно не отражено в структуре программы. Поэтому при успешном тестировании программы по критерию C2 мы можем не заметить ошибку, связанную с невыполнением некоторых условий спецификации требований. 
     Функциональный критерий - важнейший для программной индустрии критерий тестирования. Он обеспечивает, прежде всего, контроль степени выполнения требований заказчика в программном продукте. Поскольку требования формулируются к продукту в целом, они отражают взаимодействие тестируемого приложения с окружением. При функциональном тестировании преимущественно используется модель "черного ящика". Проблема функционального тестирования - это, прежде всего, трудоемкость; дело в том, что документы, фиксирующие требования к программному изделию (Software requirement specification, Functional specification и т.п.), как правило, достаточно объемны, тем не менее, соответствующая проверка должна быть всеобъемлющей. Ниже приведены частные виды функциональных критериев:
   -Тестирование пунктов спецификации - набор тестов в совокупности должен обеспечить проверку каждого тестируемого пункта не менее одного раза. Спецификация требований может содержать сотни и тысячи пунктов требований к программному продукту и каждое из этих требований при тестировании должно быть проверено в соответствии с критерием не менее чем одним тестом.
   -Тестирование классов входных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого класса входных данных не менее одного раза. При создании тестов классы входных данных сопоставляются с режимами использования тестируемого компонента или подсистемы приложения, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов. Следует заметить, что перебирая в соответствии с критерием величины входных переменных (например, различные файлы - источники входных данных), мы вынуждены применять мощные тестовые наборы. Действительно, наряду с ограничениями на величины входных данных, существуют ограничения на величины входных данных во всевозможных комбинациях, в том числе проверка реакций системы на появление ошибок в значениях или структурах входных данных. Учет этого многообразия - процесс трудоемкий, что создает сложности для применения критерия.
   -Тестирование правил - набор тестов в совокупности должен обеспечить проверку каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики. Следует заметить, что грамматика должна быть достаточно простой, чтобы трудоемкость разработки соответствующего набора тестов была реальной (вписывалась в сроки и штат специалистов, выделенных для реализации фазы тестирования).
   -Тестирование классов выходных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого выходного класса, при условии, что выходные результаты заранее расклассифицированы, причем отдельные классы результатов учитывают, в том числе, ограничения на ресурсы или на время (time out). При создании тестов классы выходных данных сопоставляются с режимами использования тестируемого компонента или подсистемы, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов.
   -Тестирование функций - набор тестов в совокупности должен обеспечить проверку каждого действия, реализуемого тестируемым модулем, не менее одного раза. Очень популярный на практике критерий, который, однако, не обеспечивает покрытия части функциональности тестируемого компонента, связанной со структурными и поведенческими свойствами, описание которых не сосредоточено в отдельных функциях (т.е. описание рассредоточено по компоненту). Критерий тестирования функций объединяет отчасти особенности структурных и функциональных критериев. Он базируется на модели "полупрозрачного ящика", где явно указаны не только входы и выходы тестируемого компонента, но также состав и структура используемых методов (функций, процедур) и классов.
Комбинированные критерии для программ и спецификаций - набор тестов в совокупности должен обеспечить проверку всех комбинаций непротиворечивых условий программ и спецификаций не менее одного раза. При этом все комбинации непротиворечивых условий надо подтвердить, а условия противоречий следует обнаружить и ликвидировать.
Стохастическое тестирование применяется при тестировании сложных программных комплексов - когда набор детерминированных тестов (X,Y) имеет громадную мощность. Мутационный критерий (класс IV). Постулируется, что профессиональные программисты пишут сразу почти правильные программы, отличающиеся от правильных мелкими ошибками или описками типа - перестановка местами максимальных значений индексов в описании массивов, ошибки в знаках арифметических операций, занижение или завышение границы цикла на 1 и т.п. Предлагается подход, позволяющий на основе мелких ошибок оценить общее число ошибок, оставшихся в программе. Подход базируется на следующих понятиях: Мутации - мелкие ошибки в программе. Мутанты - программы, отличающиеся друг от друга мутациями . Метод мутационного тестирования - в разрабатываемую программу P вносят мутации, т.е. искусственно создают программы-мутанты P1, P2... Затем программа P и ее мутанты тестируются на одном и том же наборе тестов (X,Y). Если на наборе (X,Y) подтверждается правильность программы P и, кроме того, выявляются все внесенные в программы-мутанты ошибки, то набор тестов (X,Y) соответствует мутационному критерию, а тестируемая программа объявляется правильной. Если некоторые мутанты не выявили всех мутаций, то надо расширять набор тестов (X,Y) и продолжать тестирование.

•	Принципы тестирования?

        1. Тестирование показывает наличие дефектов
	Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. Тем не менее, важно составлять тест-кейсы, которые будут находить как можно больше багов. Таким образом, при должном тестовом покрытии, тестирование позволяет снизить вероятность наличия дефектов в программном обеспечении. В то же время, даже если дефекты не были найдены в процессе тестирования, нельзя утверждать, что их нет.
	2. Исчерпывающее тестирование невозможно
	Невозможно провести исчерпывающее тестирование, которое покрывало бы все комбинации пользовательского ввода и состояний системы, за исключением совсем уж примитивных случаев. Вместо этого необходимо использовать анализ рисков и расстановку приоритетов, что позволит более эффективно распределять усилия по обеспечению качества ПО.
	3. Раннее тестирование
	Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия  должны быть сконцентрированы на определенных целях.
	4. Скопление дефектов
	Разные модули системы могут содержать разное количество дефектов – то есть, плотность скопления дефектов в разных элементах программы может отличаться. Усилия по тестированию должны распределяться пропорционально фактической плотности дефектов. В основном, большую часть критических дефектов находят в ограниченном количестве модулей. Это проявление принципа Парето: 80% проблем содержатся в 20% модулей.
	5. Парадокс пестицида
	Прогоняя одни и те же тесты вновь и вновь, Вы столкнетесь с тем, что они находят все меньше новых ошибок. Поскольку система эволюционирует, многие из ранее найденных дефектов исправляют и старые тест-кейсы больше не срабатывают.
	Чтобы преодолеть этот парадокс, необходимо периодически вносить изменения в используемые наборы тестов, рецензировать и корректировать их с тем, чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов.
	6. Тестирование зависит от контекста
	Выбор методологии, техники и типа тестирования будет напрямую зависеть от природы самой программы. Например, программное обеспечение для медицинских нужд требует гораздо более строгой и тщательной проверки, чем, скажем, компьютерная игра. Из тех же соображений, сайт с большой посещаемостью должен пройти через серьезное тестирование производительности, чтобы показать возможность работы в условиях высокой нагрузки.
	7. Заблуждение об отсутствии ошибок.
	Тот факт, что тестирование не обнаружило дефектов, еще не значит, что программа готова к релизу. Нахождение и исправление дефектов будут не важны, если система окажется неудобной в использовании, и не будет удовлетворять ожиданиям и потребностям пользователя.
	8.Верификация/Валидация

•	Что такое независимое тестирование?

Независимое тестирование (аутсорсинг тестирования) - это тестирование силами дополнительно привлечённой компании или группы людей, не участвующих непосредственно в разработке программного обеспечения. Данный подход имеет ряд положительных особенностей, позволяющих существенно повысить качество создаваемого программного продукта.
     Из самой идеи независимого тестирования следует, что работа выполняется группой людей, которые не находятся в прямом подчинении руководителя разработки программного проекта. Отсюда следует ряд важных следствий, связанных с организацией труда тестеров. Полностью исключается давление на тестеров со стороны разработчиков, как правило, ведущее к сокращению времени, выделяемого на тестирование. Тестеры работают в нормальном режиме, не подвергаются стрессовым нагрузкам, что резко снижает риски, связанные с некачественным выполнением работ по тестированию. Более того, руководителем разработки не указываются "приоритетные направления тестирования", независимые тестеры смотрят на программный продукт шире и самостоятельнее. Наконец, люди, которые начинают тестировать программу впервые, смотрят на неё "другими" глазами, чем программисты и тестеры из отдела качества компании-разработчика ПО.
     Как правило, сотрудники компании, выполняющей независимое тестирование, обладают большей квалификацией, чем персонал тестеров разработчика ПО. Для этого существуют организационные предпосылки:
-как правило, внутренние тестеры компании-разработчика имеют квалификацию ниже, чем программисты и системные аналитики, получая, соответственно, меньшую зарплату;
-при увеличении квалификации тестера он переводится в программисты;
-тестер выполняет проверку одного и того же ПО, не расширяя свой кругозор;
между выпусками версий ПО тестер недогружен и привлекается к выполнению не связанных с тестированием работ.
     Недостаток обучения и переподготовки персонала является для многих компаний основной причиной невысокого качества проведения тестирования. В противоположность этому персонал компании, проводящей независимое тестирование, специально обучен и мотивирован на нахождение максимального количества дефектов в тестируемом ПО.
     Мир программирования развивается достаточно динамично, поэтому новые методики, техники тестирования, инструменты автоматизации появляются несколько раз в год. Зачастую отделы внутреннего тестирования не могут позволить себе приобрести дорогостоящий инструмент автоматизации или провести переподготовку персонала. Такая ситуация неминуемо ведёт к снижению качества ПО.
     В этих условиях независимое тестирование становится единственным объективным способом оценки качества программного обеспечения, минимизации рисков и неопределенности. Аутсорсинг тестирования позволяет переложить на Исполнителя все заботы, связанные с:
*Наличием ресурсов для тестирования;
*Квалификацией и опытом;
*Знанием специфики;
*Компетенцией;
*Проблемами с персоналом;
*Адаптацией к меняющимся требованиям;
*Снижением времени вывода продукта на рынок.

•	Что такое тестирование со сдвигом влево?

Shift left testing
              Когда пытаются перенести тестирование на более ранний этап жизненного цикла разработки, задачи смещаются влево в схеме жизненного цикла разработки ПО (все это происходит при одновременном улучшении показателей качества). Если это возможно, тестирование должно проводиться с самого начала этапа проектирования, чтобы можно было построить соответствующую стратегию тестирования. Иными словами, это подход к тестированию программного обеспечения, при котором тестирование выполняется на более раннем этапе жизненного цикла разработки ПО.
Основные преимущества:
1)	Повышение эффективности
2)	Конкурентные преимущества
3)	Сокращение затрат
4)	Более высокое качество

•	Почему тестирование делится на отдельные этапы?
•	Какие есть этапы тестирования?
•	Как вы тестируете продукт, если требования еще не зафиксированы?
•	Как вы узнаете, было ли создано достаточно тестов для тестирования продукта?
•	Что подразумевается под тестовыми данными?

        Под тестовыми данными подразумевается набор некоторых входных значений, которые
 требуются при выполнении тест-кейсов. Эти данные определяются тестировщиками в соответствии
 с требованиями, которые предъявляются к продукту. В каких-то случаях используются специальные
 инструменты генерации, а в каких-то – это делается вручную.           

•	Что такое бета-тестирование?

 Бета-тестирование происходит на конечных пользователях. Это нужно для обеспечения обратной связи.  Существуют различные типы бета-тестов в тестировании ПО, и они заключаются в следующем: 
-Традиционное бета-тестирование: продукт распространяется на целевой рынок, и соответствующие данные собираются по всем аспектам. Эти данные могут быть использованы для улучшения продукта. 
-Публичное бета-тестирование: продукт публикуется во внешнем мире через онлайн-каналы, и данные могут быть получены от любого пользователя. На основе обратной связи могут быть сделаны улучшения продукта. 
-Техническое бета-тестирование: продукт передается во внутреннюю группу организации и собирает отзывы / данные от сотрудников организации. 
-Целевая бета-версия: продукт выпущен на рынок для сбора отзывов об особенностях программы. 
-Бета-версия после выпуска. Продукт выпущен на рынок, и данные собираются для внесения улучшений в будущем выпуске продукта.

•	Что означает пилотное тестирование? (Pilot)

PILOT testing определяется как тип тестирования программного обеспечения, который проверяет компонент системы или всю систему в режиме реального времени. 
     Целью пилотного теста является оценка осуществимости, времени, стоимости, риска и эффективности исследовательского проекта.
 Это тестирование проводится точно между UAT и Production. В пилотном тестировании выбранная группа конечных пользователей пробует тестируемую систему и предоставляет обратную связь до полного развертывания системы. Другими словами, это означает проведение генеральной репетиции для последующего теста на удобство использования. Пилотное тестирование помогает в раннем обнаружении ошибок в Системе.
      Пилотное тестирование связано с установкой системы на площадке заказчика (или в среде, моделируемой пользователем) для тестирования на предмет постоянного и регулярного использования. Выявленные недостатки затем отправляются команде разработчиков в виде отчетов об ошибках, и эти ошибки исправляются в следующей сборке системы. Во время этого процесса иногда приемочное тестирование также включается как часть тестирования на совместимость. Это происходит, когда система разрабатывается для замены старой. 

•	Что такое бизнес – логика?
•	Какие существуют основные виды тестирования ПО?

Виды тестирования ПО: 

Функциональные виды тестирования:
1)	Functional testing (Функциональное тестирование)
2)	Interoperability testing (Тестирование взаимодействия)
3)	Security and Access Control testing (Тестирование безопасности)

Нефункциональные виды тестирования:
1.	Usability testing (Тестирование удобства пользования, UI/UX)
2.	Все виды тестирования производительности
- stress testing (Стрессовое тестирование)
- load testing (Нагрузочное тестирование)
- volume testing (Объемное тестирование)
- stability/reliability testing (Тестирование стабильности или надежности)
3. Installation testing (Тестирование установки)
4. GUI testing (Тестирование графического интерфейса)
5. Failover and recovery testing (Тестирование на отказ и восстановление)
6. Internationalization testing (Тестирование интернационализации)
7. Localization testing (Тестирование локализации)
8. Configuration testing (Конфигурационное тестирование)

 Связанные с изменениями виды тестирования:
1)	Regression testing (Регрессионное тестирование)
2)	Retest (bug verified fixed)
3)	Smoke test 
4)	Sanity check
5)	Build verification test (Тестирование сборки)

•	Методы тестирования?
•	Что такое пирамида / уровни тестирования?
•	Что такое деструктивное/разрушающее/негативное тестирование? (DT — Destructive testing)
•	Что такое недеструктивное/неразрушающее/позитивное тестирование? (NDT – Non Destructive testing)
•	Что подразумевается под компонентным/модульным/юнит тестированием? (Component/Module/Unit testing)
•	Что подразумевается под интеграционным тестированием?
•	Разница между Unit testing и Integration testing?
•	Что такое системное интеграционное тестирование? (SIT — System Integration testing) 
•	В чем разница между тест-драйвером и тест-заглушкой? (Test Driver and Test Stub)
•	Что подразумевается под системным тестированием?
•	Что такое функциональное тестирование?
•	Что такое тестирование совместимости/взаимодействия? (Compatibility/Interoperability testing)
•	Что такое тестирование на соответствие? (Conformance/Compilance testing)
•	Что такое нефункциональное тестирование?
•	Что вы знаете о Тестировании удобства пользования?

Тестирование удобства пользования - это метод тестирования, направленный на установление степени удобства использования, обучаемости, понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий. [ISO 9126]
Тестирование удобства пользования дает оценку уровня удобства использования приложения по следующим пунктам:
•	производительность, эффективность (efficiency) - сколько времени и шагов понадобится пользователю для завершения основных задач приложения, например, размещение новости, регистрации, покупка и т.д.? (меньше - лучше)
•	правильность (accuracy) - сколько ошибок сделал пользователь во время работы с приложением? (меньше - лучше)
•	активизация в памяти (recall) – как много пользователь помнит о работе приложения после приостановки работы с ним на длительный период времени? (повторное выполнение операций после перерыва должно проходить быстрее чем у нового пользователя)
•	эмоциональная реакция (emotional response) – как пользователь себя чувствует после завершения задачи - растерян, испытал стресс? Порекомендует ли пользователь систему своим друзьям? (положительная реакция - лучше)

•	Отличия тестирование на удобство пользования и тестирования доступности? (Usability Vs. Accessibility testing)
•	Что такое тестирование интерфейса?
•	Что такое тестирование рабочего процесса/воркфлоу? (Workflow testing)
•	Что вы знаете о пользовательском приемочном тестировании? (UAT – User Acceptance testing)
•	Что такое эксплуатационное приемочное тестирование? (OAT — Operational Acceptance testing)
•	Что такое инсталляционное тестирование?
•	Что вы знаете о тестировании безопасности?
•	Что такое конфигурационное тестирование?
•	Объясните, что такое тестирование N+1
•	Что вы знаете о тестировании сборки? (Build Verification Test)
•	Что такое тестирование потоков? (Thread testing)
•	Что вы знаете о мутационном тестировании? (Mutation testing)
•	Что вы знаете о мутационном тестировании? (Mutation testing)

Mutation testing - это тип тестирования программного обеспечения, в котором мы меняем определенные выражения в исходном коде и проверяем, способны ли наши тест кейсы найти ошибки. Это тип тестирования относится к тестированию белого ящика, который в основном используется для модульного тестирования. Изменения в мутантной программе сохраняются довольно небольшими, поэтому это не влияет на общую цель программы. Цель мутационного тестирования - оценить качество тест кейсов, которые должны быть достаточно надежными, чтобы не выполнять этот мутантный код. Этот метод также называется стратегией тестирования, основанной на ошибках, так как он включает в себя создание ошибки в программе. 

•	Шаг 1: Ошибки вводятся в исходный код программы путем создания множества версий, которые называются мутантами. Каждый мутант должен содержать только одну ошибку, и цель состоит в том, чтобы заставить версию мутанта потерпеть неудачу, что демонстрирует эффективность тест кейса. 
•	Шаг 2: Тест кейсы применяются к исходной программе, а также к программе мутанта. 
•	Шаг 3: Происходит сравнение результатов оригинальной и мутантной программ. 
•	Шаг 4: Если исходная программа и программы-мутанты генерируют разные выходные данные, то этот мутант уничтожается тест кейсом. Таким образом, тест кейс достаточно хорош, чтобы обнаружить изменение между оригинальной и мутантной программами. 
•	Шаг 5: Если исходная программа и программа-мутант генерируют одинаковые выходные данные, мутант остается в живых. В таких случаях необходимо создать более эффективные тест кейсы, которые будут убивать всех мутантов.

•	В чем разница между Baseline и Benchmark testing?
•	Что такое A/B тестирование?
•	Что означает сквозное тестирование? (E2E — End–to–End)
•	В чем разница между E2E и системным тестированием?
•	Что такое параллельное тестирование? (Parallel testing)
•	Чем AdHock тестирование отличается от Исследовательского тестирования?


